/**
 * \file
 * \brief	Syndrome-generator validator
 *
 * @author	Dominic Eschweiler weiler@upb.de
 *
 * Status	: STABLE \n
 * Date of creation : 21.5.2008
 *
 */

/*****************************************************************
 *
 * Barracuda is a experimental microdriver extension to the 
 * linux-kernel that is able to outsource common functions to
 * the userspace. It was intensionally designed to accelerate
 * CPU-intensive Tasks on a GPU.
 *
 * Copyright (C) 2009 Dominic Eschweiler
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation; either only GPLv2 - 
 * version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful, 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public 
 * License along with this program; 
 * if not, see <http://www.gnu.org/licenses/>.
 *
 *****************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <dirent.h>
#include <math.h>
#include <time.h>

#include <sys/time.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <sys/types.h>

#include <linux/types.h>

# include "validator.h"
# include "service.h"

HOST int compare_syndrome(int disks, int bytes, void **ptrs_van, void **ptrs_cho);



/**
 * Generates a random datasaet to test the choosen implementation against
 * the vanilla version that was extracted from the kernel.
 * 
 *
 * @param gen_syndrome			: Target function pointer
 * @param gen_syndrome_list[]	: Array pointer to the availaible implementations
 *
 * @returns		EXIT_FAILURE if implmenations output is valid, 
 *              EXIT_SUCCESS if implmenations output is valid
 */

HOST int validate_implemenataion( syndrome_func gen_syndrome, syndrome_func gen_syndrome_list[] )
{
#ifdef DEBUG_LEVEL_1
	printf("DEBUG 1 : Pagesize in validator is = %d\n", PAGE_SIZE);
#endif

int retval = 0;
//int bytes  = 1048576;
int bytes  = 512;
//int bytes  = 2097152;
int i;
	
/* make the code a little more readable */
void (*choosen_gen_syndrome)GEN_SYNDROME = gen_syndrome;
void (*vanilla_gen_syndrome)GEN_SYNDROME = gen_syndrome_list[0];

/* Allocate input dpointers */
void **vanilla_dptrs = allocate_host_example_dpointer( bytes, 7);
void **choosen_dptrs = allocate_host_example_dpointer( bytes, 7);
	
/* Fill all pointers */
for ( i=0 ; i < 7 ; i++ ){
	memset(vanilla_dptrs[i], i, bytes);
	memset(choosen_dptrs[i], i, bytes);
	}
	
/* Call functions*/	
vanilla_gen_syndrome(7, bytes, vanilla_dptrs);
choosen_gen_syndrome(7, bytes, choosen_dptrs);

/* Compare results */
retval = compare_syndrome(7, bytes, vanilla_dptrs, choosen_dptrs);

/* Print results from the choosen implementation */

#ifdef VALIDATOR_EXPLICIT_OUTPUT
char *tmp;
int j;
bytes = 128;
for ( i=5; i < 7; i++ ){
	tmp = (char *)choosen_dptrs[i];
	for ( j=0; j < bytes; j++ ){
		printf("%u ", tmp[j]);
		}
	
	printf("\n\n");
	
	tmp = (char *)vanilla_dptrs[i];
	for ( j=0; j < bytes; j++ ){
		printf("%u ", tmp[j]);
		}
	printf("\n\n\n");
	}
#endif
	
/* 
 * Free the datapointers. All example data-pointers are pointing to exact the same
 * page in the main-memory. Therfore it is feasible to deallocate only one of its
 * pointers.
 *
 */
free(vanilla_dptrs[0]);
free(vanilla_dptrs);
free(choosen_dptrs[0]);
free(choosen_dptrs);
	
return retval;
}



/**
 * Compares two syndromes
 *
 * @param disks			: # of disks
 * @param bytes			: # of bytes
 * @param **ptrs_van	: syndrome generated by the software implementation
 * @param **ptrs_cho	: syndrome generated by the choosen implementation
 *
 * @returns		EXIT_FAILURE if the syndromes are not equal 
 *              EXIT_SUCCESS if the syndromes are equal
 */

HOST int compare_syndrome(int disks, int bytes, void **ptrs_van, void **ptrs_cho)
{
int i;
	
u8 **dptrs_van = (u8 **)ptrs_van;
u8 **dptrs_cho = (u8 **)ptrs_cho;
	
u8 *xor_van = dptrs_van[disks-2];
u8 *xor_cho = dptrs_cho[disks-2];
	
u8 *syn_van = dptrs_van[disks-1];
u8 *syn_cho = dptrs_cho[disks-1];
	
for(i=0; i < bytes; i++){
	
	if( xor_van[i] != xor_cho[i] ){	
		return EXIT_FAILURE;
		}
	
	if( syn_van[i] != syn_cho[i] ){
		return EXIT_FAILURE;
		}
	}

return EXIT_SUCCESS;
}
